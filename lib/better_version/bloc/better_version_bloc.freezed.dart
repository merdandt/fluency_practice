// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'better_version_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$BetterVersionEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() betterVersionLoaded,
    required TResult Function() betterVersionTextTransformed,
    required TResult Function() betterVersionTextTransformationInterrupted,
    required TResult Function() betterVersionPlayStoped,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? betterVersionLoaded,
    TResult? Function()? betterVersionTextTransformed,
    TResult? Function()? betterVersionTextTransformationInterrupted,
    TResult? Function()? betterVersionPlayStoped,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? betterVersionLoaded,
    TResult Function()? betterVersionTextTransformed,
    TResult Function()? betterVersionTextTransformationInterrupted,
    TResult Function()? betterVersionPlayStoped,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BetterVersionLoaded value) betterVersionLoaded,
    required TResult Function(BetterVersionTextTransformed value)
        betterVersionTextTransformed,
    required TResult Function(BetterVersionTextTransformationInterrupted value)
        betterVersionTextTransformationInterrupted,
    required TResult Function(BetterVersionPlayStoped value)
        betterVersionPlayStoped,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BetterVersionLoaded value)? betterVersionLoaded,
    TResult? Function(BetterVersionTextTransformed value)?
        betterVersionTextTransformed,
    TResult? Function(BetterVersionTextTransformationInterrupted value)?
        betterVersionTextTransformationInterrupted,
    TResult? Function(BetterVersionPlayStoped value)? betterVersionPlayStoped,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BetterVersionLoaded value)? betterVersionLoaded,
    TResult Function(BetterVersionTextTransformed value)?
        betterVersionTextTransformed,
    TResult Function(BetterVersionTextTransformationInterrupted value)?
        betterVersionTextTransformationInterrupted,
    TResult Function(BetterVersionPlayStoped value)? betterVersionPlayStoped,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BetterVersionEventCopyWith<$Res> {
  factory $BetterVersionEventCopyWith(
          BetterVersionEvent value, $Res Function(BetterVersionEvent) then) =
      _$BetterVersionEventCopyWithImpl<$Res, BetterVersionEvent>;
}

/// @nodoc
class _$BetterVersionEventCopyWithImpl<$Res, $Val extends BetterVersionEvent>
    implements $BetterVersionEventCopyWith<$Res> {
  _$BetterVersionEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BetterVersionEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$BetterVersionLoadedImplCopyWith<$Res> {
  factory _$$BetterVersionLoadedImplCopyWith(_$BetterVersionLoadedImpl value,
          $Res Function(_$BetterVersionLoadedImpl) then) =
      __$$BetterVersionLoadedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BetterVersionLoadedImplCopyWithImpl<$Res>
    extends _$BetterVersionEventCopyWithImpl<$Res, _$BetterVersionLoadedImpl>
    implements _$$BetterVersionLoadedImplCopyWith<$Res> {
  __$$BetterVersionLoadedImplCopyWithImpl(_$BetterVersionLoadedImpl _value,
      $Res Function(_$BetterVersionLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of BetterVersionEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BetterVersionLoadedImpl
    with DiagnosticableTreeMixin
    implements BetterVersionLoaded {
  const _$BetterVersionLoadedImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BetterVersionEvent.betterVersionLoaded()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(
        DiagnosticsProperty('type', 'BetterVersionEvent.betterVersionLoaded'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BetterVersionLoadedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() betterVersionLoaded,
    required TResult Function() betterVersionTextTransformed,
    required TResult Function() betterVersionTextTransformationInterrupted,
    required TResult Function() betterVersionPlayStoped,
  }) {
    return betterVersionLoaded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? betterVersionLoaded,
    TResult? Function()? betterVersionTextTransformed,
    TResult? Function()? betterVersionTextTransformationInterrupted,
    TResult? Function()? betterVersionPlayStoped,
  }) {
    return betterVersionLoaded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? betterVersionLoaded,
    TResult Function()? betterVersionTextTransformed,
    TResult Function()? betterVersionTextTransformationInterrupted,
    TResult Function()? betterVersionPlayStoped,
    required TResult orElse(),
  }) {
    if (betterVersionLoaded != null) {
      return betterVersionLoaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BetterVersionLoaded value) betterVersionLoaded,
    required TResult Function(BetterVersionTextTransformed value)
        betterVersionTextTransformed,
    required TResult Function(BetterVersionTextTransformationInterrupted value)
        betterVersionTextTransformationInterrupted,
    required TResult Function(BetterVersionPlayStoped value)
        betterVersionPlayStoped,
  }) {
    return betterVersionLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BetterVersionLoaded value)? betterVersionLoaded,
    TResult? Function(BetterVersionTextTransformed value)?
        betterVersionTextTransformed,
    TResult? Function(BetterVersionTextTransformationInterrupted value)?
        betterVersionTextTransformationInterrupted,
    TResult? Function(BetterVersionPlayStoped value)? betterVersionPlayStoped,
  }) {
    return betterVersionLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BetterVersionLoaded value)? betterVersionLoaded,
    TResult Function(BetterVersionTextTransformed value)?
        betterVersionTextTransformed,
    TResult Function(BetterVersionTextTransformationInterrupted value)?
        betterVersionTextTransformationInterrupted,
    TResult Function(BetterVersionPlayStoped value)? betterVersionPlayStoped,
    required TResult orElse(),
  }) {
    if (betterVersionLoaded != null) {
      return betterVersionLoaded(this);
    }
    return orElse();
  }
}

abstract class BetterVersionLoaded implements BetterVersionEvent {
  const factory BetterVersionLoaded() = _$BetterVersionLoadedImpl;
}

/// @nodoc
abstract class _$$BetterVersionTextTransformedImplCopyWith<$Res> {
  factory _$$BetterVersionTextTransformedImplCopyWith(
          _$BetterVersionTextTransformedImpl value,
          $Res Function(_$BetterVersionTextTransformedImpl) then) =
      __$$BetterVersionTextTransformedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BetterVersionTextTransformedImplCopyWithImpl<$Res>
    extends _$BetterVersionEventCopyWithImpl<$Res,
        _$BetterVersionTextTransformedImpl>
    implements _$$BetterVersionTextTransformedImplCopyWith<$Res> {
  __$$BetterVersionTextTransformedImplCopyWithImpl(
      _$BetterVersionTextTransformedImpl _value,
      $Res Function(_$BetterVersionTextTransformedImpl) _then)
      : super(_value, _then);

  /// Create a copy of BetterVersionEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BetterVersionTextTransformedImpl
    with DiagnosticableTreeMixin
    implements BetterVersionTextTransformed {
  const _$BetterVersionTextTransformedImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BetterVersionEvent.betterVersionTextTransformed()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty(
        'type', 'BetterVersionEvent.betterVersionTextTransformed'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BetterVersionTextTransformedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() betterVersionLoaded,
    required TResult Function() betterVersionTextTransformed,
    required TResult Function() betterVersionTextTransformationInterrupted,
    required TResult Function() betterVersionPlayStoped,
  }) {
    return betterVersionTextTransformed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? betterVersionLoaded,
    TResult? Function()? betterVersionTextTransformed,
    TResult? Function()? betterVersionTextTransformationInterrupted,
    TResult? Function()? betterVersionPlayStoped,
  }) {
    return betterVersionTextTransformed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? betterVersionLoaded,
    TResult Function()? betterVersionTextTransformed,
    TResult Function()? betterVersionTextTransformationInterrupted,
    TResult Function()? betterVersionPlayStoped,
    required TResult orElse(),
  }) {
    if (betterVersionTextTransformed != null) {
      return betterVersionTextTransformed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BetterVersionLoaded value) betterVersionLoaded,
    required TResult Function(BetterVersionTextTransformed value)
        betterVersionTextTransformed,
    required TResult Function(BetterVersionTextTransformationInterrupted value)
        betterVersionTextTransformationInterrupted,
    required TResult Function(BetterVersionPlayStoped value)
        betterVersionPlayStoped,
  }) {
    return betterVersionTextTransformed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BetterVersionLoaded value)? betterVersionLoaded,
    TResult? Function(BetterVersionTextTransformed value)?
        betterVersionTextTransformed,
    TResult? Function(BetterVersionTextTransformationInterrupted value)?
        betterVersionTextTransformationInterrupted,
    TResult? Function(BetterVersionPlayStoped value)? betterVersionPlayStoped,
  }) {
    return betterVersionTextTransformed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BetterVersionLoaded value)? betterVersionLoaded,
    TResult Function(BetterVersionTextTransformed value)?
        betterVersionTextTransformed,
    TResult Function(BetterVersionTextTransformationInterrupted value)?
        betterVersionTextTransformationInterrupted,
    TResult Function(BetterVersionPlayStoped value)? betterVersionPlayStoped,
    required TResult orElse(),
  }) {
    if (betterVersionTextTransformed != null) {
      return betterVersionTextTransformed(this);
    }
    return orElse();
  }
}

abstract class BetterVersionTextTransformed implements BetterVersionEvent {
  const factory BetterVersionTextTransformed() =
      _$BetterVersionTextTransformedImpl;
}

/// @nodoc
abstract class _$$BetterVersionTextTransformationInterruptedImplCopyWith<$Res> {
  factory _$$BetterVersionTextTransformationInterruptedImplCopyWith(
          _$BetterVersionTextTransformationInterruptedImpl value,
          $Res Function(_$BetterVersionTextTransformationInterruptedImpl)
              then) =
      __$$BetterVersionTextTransformationInterruptedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BetterVersionTextTransformationInterruptedImplCopyWithImpl<$Res>
    extends _$BetterVersionEventCopyWithImpl<$Res,
        _$BetterVersionTextTransformationInterruptedImpl>
    implements _$$BetterVersionTextTransformationInterruptedImplCopyWith<$Res> {
  __$$BetterVersionTextTransformationInterruptedImplCopyWithImpl(
      _$BetterVersionTextTransformationInterruptedImpl _value,
      $Res Function(_$BetterVersionTextTransformationInterruptedImpl) _then)
      : super(_value, _then);

  /// Create a copy of BetterVersionEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BetterVersionTextTransformationInterruptedImpl
    with DiagnosticableTreeMixin
    implements BetterVersionTextTransformationInterrupted {
  const _$BetterVersionTextTransformationInterruptedImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BetterVersionEvent.betterVersionTextTransformationInterrupted()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type',
        'BetterVersionEvent.betterVersionTextTransformationInterrupted'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BetterVersionTextTransformationInterruptedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() betterVersionLoaded,
    required TResult Function() betterVersionTextTransformed,
    required TResult Function() betterVersionTextTransformationInterrupted,
    required TResult Function() betterVersionPlayStoped,
  }) {
    return betterVersionTextTransformationInterrupted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? betterVersionLoaded,
    TResult? Function()? betterVersionTextTransformed,
    TResult? Function()? betterVersionTextTransformationInterrupted,
    TResult? Function()? betterVersionPlayStoped,
  }) {
    return betterVersionTextTransformationInterrupted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? betterVersionLoaded,
    TResult Function()? betterVersionTextTransformed,
    TResult Function()? betterVersionTextTransformationInterrupted,
    TResult Function()? betterVersionPlayStoped,
    required TResult orElse(),
  }) {
    if (betterVersionTextTransformationInterrupted != null) {
      return betterVersionTextTransformationInterrupted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BetterVersionLoaded value) betterVersionLoaded,
    required TResult Function(BetterVersionTextTransformed value)
        betterVersionTextTransformed,
    required TResult Function(BetterVersionTextTransformationInterrupted value)
        betterVersionTextTransformationInterrupted,
    required TResult Function(BetterVersionPlayStoped value)
        betterVersionPlayStoped,
  }) {
    return betterVersionTextTransformationInterrupted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BetterVersionLoaded value)? betterVersionLoaded,
    TResult? Function(BetterVersionTextTransformed value)?
        betterVersionTextTransformed,
    TResult? Function(BetterVersionTextTransformationInterrupted value)?
        betterVersionTextTransformationInterrupted,
    TResult? Function(BetterVersionPlayStoped value)? betterVersionPlayStoped,
  }) {
    return betterVersionTextTransformationInterrupted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BetterVersionLoaded value)? betterVersionLoaded,
    TResult Function(BetterVersionTextTransformed value)?
        betterVersionTextTransformed,
    TResult Function(BetterVersionTextTransformationInterrupted value)?
        betterVersionTextTransformationInterrupted,
    TResult Function(BetterVersionPlayStoped value)? betterVersionPlayStoped,
    required TResult orElse(),
  }) {
    if (betterVersionTextTransformationInterrupted != null) {
      return betterVersionTextTransformationInterrupted(this);
    }
    return orElse();
  }
}

abstract class BetterVersionTextTransformationInterrupted
    implements BetterVersionEvent {
  const factory BetterVersionTextTransformationInterrupted() =
      _$BetterVersionTextTransformationInterruptedImpl;
}

/// @nodoc
abstract class _$$BetterVersionPlayStopedImplCopyWith<$Res> {
  factory _$$BetterVersionPlayStopedImplCopyWith(
          _$BetterVersionPlayStopedImpl value,
          $Res Function(_$BetterVersionPlayStopedImpl) then) =
      __$$BetterVersionPlayStopedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BetterVersionPlayStopedImplCopyWithImpl<$Res>
    extends _$BetterVersionEventCopyWithImpl<$Res,
        _$BetterVersionPlayStopedImpl>
    implements _$$BetterVersionPlayStopedImplCopyWith<$Res> {
  __$$BetterVersionPlayStopedImplCopyWithImpl(
      _$BetterVersionPlayStopedImpl _value,
      $Res Function(_$BetterVersionPlayStopedImpl) _then)
      : super(_value, _then);

  /// Create a copy of BetterVersionEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BetterVersionPlayStopedImpl
    with DiagnosticableTreeMixin
    implements BetterVersionPlayStoped {
  const _$BetterVersionPlayStopedImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BetterVersionEvent.betterVersionPlayStoped()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty(
        'type', 'BetterVersionEvent.betterVersionPlayStoped'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BetterVersionPlayStopedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() betterVersionLoaded,
    required TResult Function() betterVersionTextTransformed,
    required TResult Function() betterVersionTextTransformationInterrupted,
    required TResult Function() betterVersionPlayStoped,
  }) {
    return betterVersionPlayStoped();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? betterVersionLoaded,
    TResult? Function()? betterVersionTextTransformed,
    TResult? Function()? betterVersionTextTransformationInterrupted,
    TResult? Function()? betterVersionPlayStoped,
  }) {
    return betterVersionPlayStoped?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? betterVersionLoaded,
    TResult Function()? betterVersionTextTransformed,
    TResult Function()? betterVersionTextTransformationInterrupted,
    TResult Function()? betterVersionPlayStoped,
    required TResult orElse(),
  }) {
    if (betterVersionPlayStoped != null) {
      return betterVersionPlayStoped();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BetterVersionLoaded value) betterVersionLoaded,
    required TResult Function(BetterVersionTextTransformed value)
        betterVersionTextTransformed,
    required TResult Function(BetterVersionTextTransformationInterrupted value)
        betterVersionTextTransformationInterrupted,
    required TResult Function(BetterVersionPlayStoped value)
        betterVersionPlayStoped,
  }) {
    return betterVersionPlayStoped(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BetterVersionLoaded value)? betterVersionLoaded,
    TResult? Function(BetterVersionTextTransformed value)?
        betterVersionTextTransformed,
    TResult? Function(BetterVersionTextTransformationInterrupted value)?
        betterVersionTextTransformationInterrupted,
    TResult? Function(BetterVersionPlayStoped value)? betterVersionPlayStoped,
  }) {
    return betterVersionPlayStoped?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BetterVersionLoaded value)? betterVersionLoaded,
    TResult Function(BetterVersionTextTransformed value)?
        betterVersionTextTransformed,
    TResult Function(BetterVersionTextTransformationInterrupted value)?
        betterVersionTextTransformationInterrupted,
    TResult Function(BetterVersionPlayStoped value)? betterVersionPlayStoped,
    required TResult orElse(),
  }) {
    if (betterVersionPlayStoped != null) {
      return betterVersionPlayStoped(this);
    }
    return orElse();
  }
}

abstract class BetterVersionPlayStoped implements BetterVersionEvent {
  const factory BetterVersionPlayStoped() = _$BetterVersionPlayStopedImpl;
}

/// @nodoc
mixin _$BetterVersionState {
  String get userTranscript => throw _privateConstructorUsedError;
  LoadingState get loadingState => throw _privateConstructorUsedError;
  SpeakingState get speakingState => throw _privateConstructorUsedError;
  String? get betterVersion => throw _privateConstructorUsedError;

  /// Create a copy of BetterVersionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BetterVersionStateCopyWith<BetterVersionState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BetterVersionStateCopyWith<$Res> {
  factory $BetterVersionStateCopyWith(
          BetterVersionState value, $Res Function(BetterVersionState) then) =
      _$BetterVersionStateCopyWithImpl<$Res, BetterVersionState>;
  @useResult
  $Res call(
      {String userTranscript,
      LoadingState loadingState,
      SpeakingState speakingState,
      String? betterVersion});
}

/// @nodoc
class _$BetterVersionStateCopyWithImpl<$Res, $Val extends BetterVersionState>
    implements $BetterVersionStateCopyWith<$Res> {
  _$BetterVersionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BetterVersionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userTranscript = null,
    Object? loadingState = null,
    Object? speakingState = null,
    Object? betterVersion = freezed,
  }) {
    return _then(_value.copyWith(
      userTranscript: null == userTranscript
          ? _value.userTranscript
          : userTranscript // ignore: cast_nullable_to_non_nullable
              as String,
      loadingState: null == loadingState
          ? _value.loadingState
          : loadingState // ignore: cast_nullable_to_non_nullable
              as LoadingState,
      speakingState: null == speakingState
          ? _value.speakingState
          : speakingState // ignore: cast_nullable_to_non_nullable
              as SpeakingState,
      betterVersion: freezed == betterVersion
          ? _value.betterVersion
          : betterVersion // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BetterVersionStateImplCopyWith<$Res>
    implements $BetterVersionStateCopyWith<$Res> {
  factory _$$BetterVersionStateImplCopyWith(_$BetterVersionStateImpl value,
          $Res Function(_$BetterVersionStateImpl) then) =
      __$$BetterVersionStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String userTranscript,
      LoadingState loadingState,
      SpeakingState speakingState,
      String? betterVersion});
}

/// @nodoc
class __$$BetterVersionStateImplCopyWithImpl<$Res>
    extends _$BetterVersionStateCopyWithImpl<$Res, _$BetterVersionStateImpl>
    implements _$$BetterVersionStateImplCopyWith<$Res> {
  __$$BetterVersionStateImplCopyWithImpl(_$BetterVersionStateImpl _value,
      $Res Function(_$BetterVersionStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of BetterVersionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userTranscript = null,
    Object? loadingState = null,
    Object? speakingState = null,
    Object? betterVersion = freezed,
  }) {
    return _then(_$BetterVersionStateImpl(
      userTranscript: null == userTranscript
          ? _value.userTranscript
          : userTranscript // ignore: cast_nullable_to_non_nullable
              as String,
      loadingState: null == loadingState
          ? _value.loadingState
          : loadingState // ignore: cast_nullable_to_non_nullable
              as LoadingState,
      speakingState: null == speakingState
          ? _value.speakingState
          : speakingState // ignore: cast_nullable_to_non_nullable
              as SpeakingState,
      betterVersion: freezed == betterVersion
          ? _value.betterVersion
          : betterVersion // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$BetterVersionStateImpl extends _BetterVersionState
    with DiagnosticableTreeMixin {
  const _$BetterVersionStateImpl(
      {required this.userTranscript,
      required this.loadingState,
      required this.speakingState,
      this.betterVersion})
      : super._();

  @override
  final String userTranscript;
  @override
  final LoadingState loadingState;
  @override
  final SpeakingState speakingState;
  @override
  final String? betterVersion;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BetterVersionState(userTranscript: $userTranscript, loadingState: $loadingState, speakingState: $speakingState, betterVersion: $betterVersion)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BetterVersionState'))
      ..add(DiagnosticsProperty('userTranscript', userTranscript))
      ..add(DiagnosticsProperty('loadingState', loadingState))
      ..add(DiagnosticsProperty('speakingState', speakingState))
      ..add(DiagnosticsProperty('betterVersion', betterVersion));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BetterVersionStateImpl &&
            (identical(other.userTranscript, userTranscript) ||
                other.userTranscript == userTranscript) &&
            (identical(other.loadingState, loadingState) ||
                other.loadingState == loadingState) &&
            (identical(other.speakingState, speakingState) ||
                other.speakingState == speakingState) &&
            (identical(other.betterVersion, betterVersion) ||
                other.betterVersion == betterVersion));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, userTranscript, loadingState, speakingState, betterVersion);

  /// Create a copy of BetterVersionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BetterVersionStateImplCopyWith<_$BetterVersionStateImpl> get copyWith =>
      __$$BetterVersionStateImplCopyWithImpl<_$BetterVersionStateImpl>(
          this, _$identity);
}

abstract class _BetterVersionState extends BetterVersionState {
  const factory _BetterVersionState(
      {required final String userTranscript,
      required final LoadingState loadingState,
      required final SpeakingState speakingState,
      final String? betterVersion}) = _$BetterVersionStateImpl;
  const _BetterVersionState._() : super._();

  @override
  String get userTranscript;
  @override
  LoadingState get loadingState;
  @override
  SpeakingState get speakingState;
  @override
  String? get betterVersion;

  /// Create a copy of BetterVersionState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BetterVersionStateImplCopyWith<_$BetterVersionStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
